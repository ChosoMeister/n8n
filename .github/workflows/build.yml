name: build-and-push

on:
  push:
    branches: [ master, main ]
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: chosomeister/n8n
  IMAGE_TAG: enterprise

permissions:
  contents: read
  packages: write

jobs:
  build-and-push:
    name: Build and Push n8n Image
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Clone upstream n8n (latest stable tag)
        run: |
          set -euo pipefail
          git clone https://github.com/n8n-io/n8n.git n8n-source
          cd n8n-source
          releases_json=$(curl -s https://api.github.com/repos/n8n-io/n8n/releases)
          latest_stable_tag=$(echo "$releases_json" | jq -r '.[] | select(.prerelease == false) | .tag_name' | head -n 1)
          if [ -n "$latest_stable_tag" ] && git rev-parse --verify "$latest_stable_tag" >/dev/null 2>&1; then
            git checkout "$latest_stable_tag"
          fi
          echo "N8N_COMMIT_HASH=$(git rev-parse HEAD)" >> "$GITHUB_ENV"
          echo "Checked out tag: ${latest_stable_tag:-"(left at default branch)"}"

      - name: Apply license bypass (if provided)
        run: |
          set -euo pipefail
          if [ -f "bypass.sh" ]; then
            cp bypass.sh n8n-source/
            echo "bypass.sh copied to n8n-source"
          else
            echo "bypass.sh not found in root; skipping copy"
          fi
          cd n8n-source
          if [ -f "bypass.sh" ]; then
            chmod +x bypass.sh
            # auto mode for CI
            ./bypass.sh --auto
            echo "bypass.sh executed (auto mode)"
          else
            echo "No bypass.sh inside n8n-source; skipping execution"
          fi

      - name: Use Node.js 22
        uses: actions/setup-node@v4
        with:
          node-version: 22

      - name: Setup pnpm
        uses: pnpm/action-setup@v2
        with:
          version: latest
          dest: ~/setup-pnpm

      - name: Compute pnpm store path
        run: echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV

      - name: Restore pnpm store cache
        uses: actions/cache@v3
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: Install dependencies
        working-directory: n8n-source
        run: pnpm install --frozen-lockfile

      - name: Build n8n monorepo
        working-directory: n8n-source
        run: pnpm run build

      # Buildx setup + login
      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Build AND push in one atomic step (no local load, less brittle)
      - name: Buildx: build & push to registry (multi-tag)
        working-directory: n8n-source
        env:
          REGISTRY: ${{ env.REGISTRY }}
          IMAGE_NAME: ${{ env.IMAGE_NAME }}
          IMAGE_TAG: ${{ env.IMAGE_TAG }}
        run: |
          set -euo pipefail
          # create full image names
          FULL_TAG="${REGISTRY}/${IMAGE_NAME}:${IMAGE_TAG}"
          FULL_LATEST="${REGISTRY}/${IMAGE_NAME}:latest"

          # Use buildx to build and push directly to registry (avoids local daemon issues)
          docker buildx build \
            --platform=linux/amd64 \
            -t "$FULL_TAG" \
            -t "$FULL_LATEST" \
            --push \
            -f docker/images/n8n/Dockerfile .

      # Optional: verify that pushed image exists on registry by querying registry API (best-effort)
      - name: Verify GHCR image (best-effort)
        if: always()
        run: |
          set -euo pipefail
          # This check is best-effort — GHCR APIs require auth; we use docker manifest inspect as a lightweight check.
          FULL_TAG="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.IMAGE_TAG }}"
          echo "Checking image manifest for $FULL_TAG"
          if docker manifest inspect "$FULL_TAG" > /dev/null 2>&1; then
            echo "Image $FULL_TAG found (manifest present)"
          else
            echo "Warning: docker manifest inspect failed to find $FULL_TAG — check build logs or GHCR UI"
            # do not fail here to allow human inspection; remove next line if you want CI to fail instead
            # exit 1
          fi
